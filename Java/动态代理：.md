动态代理：

为什么通过代理类的对象，调用方法时，就会自动的调用InvocationHandler实现类(以后统称为：MyInvocationHandler此类)的invoke() ？

因为生成代理类对象的方法中含有一个参数(handler)，该参数就MyInvocationHandler此类的一个对象，当代理类调用代理类的方法时，由于生成代理类的方法自动传递过一个参数(handler)，这个调用就会打包传递，找该参数(handler)对应的类MyInvocationHandler里边的invoke()



```java
/*
要想实现动态代理，需要解决的问题？
问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。
问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。
 */


// 代理类
class ProxyFactory{
    //调用此方法，返回一个代理类的对象  解决问题一。
    public static Object getProxyInstance(Object obj){ //obj:被代理类的对象

        /**
         * InvocationHandler接口，
         * handler被实例化的对象
         * handler 需要填入代理类对象的参数中
         */
        MyInvocationHandler handler = new MyInvocationHandler(obj);

        /**
         * 返回一个代理类的对象
         */
        return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),handler);
    }
}



/**
 * InvocationHandler接口的实现类
 *
 * InvocationHandler接口注释是这么说的,每当调用代理类的方法，
 * 这个调用就会打包传递给InvocationHandler的invoke方法
 */
class  MyInvocationHandler implements InvocationHandler{

    private Object obj; //需要使用被代理类的对象进行赋值

    public MyInvocationHandler(Object obj) {
        this.obj = obj;
    }




    //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()
    //将被代理类要执行的方法a的功能就声明在invoke()中

    /**
     * 为什么通过代理类的对象，调用方法时，就会自动的调用InvocationHandler实现类(以后统称为：MyInvocationHandler此类)的invoke() ？
     *
     * 因为生成代理类对象的方法中含有一个参数(handler)，该参数就是MyInvocationHandler此类的一个对象，
     * 当代理类调用代理类的方法时，由于生成代理类的方法自动传递过一个参数(handler)，
     * 该方法就会找该参数(handler)对应的类MyInvocationHandler里边的invoke()
     *
     * @param proxy 代理类的对象
     * @param method  代理类的对象所调用的方法
     * @param args
     * @return
     * @throws Throwable
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        //method()：即为代理类对象调用的方法，此方法就作为了被代理类对象调用的方法
        //obj:被代理类的对象
        Object returnValue = method.invoke(obj, args);  //填入obj参数调用被代理类的对象的方法

        //被代理类对象所调用方法的返回值
        return returnValue;
    }
}

```



